/* eslint-disable @typescript-eslint/camelcase */
import * as path from "path";
import { queue, objectives } from "./queue";
import {
  CodeGenerator,
  McFunction,
  LootInput,
  DataPackFile,
  TagType,
  Tag,
  LootTable,
  FileType,
  Objective,
  Command,
  DataPackExport,
} from "./types";
import { SelectorArgs, Selector, SelectorFunction } from "./game-types";
import { command, scoreboard } from "./commands";

const rootTags = new Map<string, Tag>();

export default class DataPack {
  private initScoreboards: Command[];

  constructor(private namespace: string, private scoreboardNamespace: string) {
    const initScoreboards: Command[] = [];
    // TODO: use this to initialize scoreboards. I can't call mcLoad from
    // DataPack's constructor, because it's a function on DataPack.
    this.initScoreboards = initScoreboards;

    // const initialize_scoreboards = this.mcFunction(
    //   function* initialize_scoreboards() {
    //     for (let index = 0; index < initScoreboards.length; index++) {
    //       yield initScoreboards[index];
    //     }
    //   }
    // );
    // mcLoad(initialize_scoreboards);
  }

  public register(data: DataPackExport): void {
    Object.entries(data.tags).forEach(([type, tagMap = {}]) => {
      return Object.keys(tagMap)
        .map(String)
        .forEach((fullName) => {
          if (!rootTags.has(fullName)) {
            const [namespace, name] = fullName.split(":");
            const tag = this.namespacedTag(namespace, type as TagType, name);
            rootTags.set(fullName, tag);
          }
          const tag = rootTags.get(fullName)!;
          tag(...tagMap[fullName]);
          return tag;
        });
    });
  }
  public run(): void {
    rootTags.forEach((s) => {
      String(s);
    });
  }

  public objective(name: string, criteria: Objective["criteria"]): Objective {
    objectives.push(
      `scoreboard objectives add ${this.scoreboardNamespace}.${name} ${criteria}\n`
    );
    let fullName: string;
    const myObjective = {
      criteria,
      name,
      toString: (): string => {
        if (!fullName) {
          fullName = `${this.scoreboardNamespace}.${name}`;
          this.initScoreboards.push(
            scoreboard("objectives", "add", myObjective)
          );
        }
        return fullName;
      },
    };
    return myObjective;
  }

  public mcFunction(fn: CodeGenerator, name: string = fn.name): McFunction {
    if (!name) {
      throw new Error(
        "missing name. Either use a function declaration or pass a name"
      );
    }
    const filename = path.join(
      "data",
      this.namespace,
      "functions",
      `${name}.mcfunction`
    );

    const mcFn: McFunction = Object.assign(fn, {
      type: FileType.McFunction,
      filename,
      toString: (): string => {
        if (!queue.includes(mcFn)) {
          queue.push(mcFn);
        }
        return `${this.namespace}:${name}`;
      },
      content(): string {
        let content = "# Generated by ts-datapack\n\n";
        for (let cmd of fn()) {
          // If you just pass an McFunciton directly, this assumes you want to run it
          // with the `function` command. since funciton is a keyword in JS, I can't
          // make a function(fn: McFunction): string
          if (typeof cmd === "function") {
            cmd = command(`function ${cmd}`);
          }

          content += String(cmd).trim() + "\n\n";
        }
        return content
          .split(/\r?\n/)
          .map((s) => s.trim())
          .join("\n");
      },
    } as const);
    return mcFn;
  }

  public makeLootTable(name: string, table: LootInput): LootTable {
    const filename = path.join(
      "data",
      this.namespace,
      "loot_tables",
      `${name}.json`
    );

    const lootTable: LootTable = {
      type: FileType.LootTable,
      filename,
      toString: (): string => {
        const fullName = `${this.namespace}:${name}`;
        if (!queue.includes(lootTable)) {
          queue.push(lootTable);
        }
        return fullName;
      },
      content: (): string => JSON.stringify(table(), null, 2),
    };
    return lootTable;
  }

  private namespacedTag<T extends TagType>(
    namespace: string,
    type: T,
    name: string
  ): Tag<T> {
    const filename = path.join("data", namespace, "tags", type, name + ".json");

    const values: Tag<T>["values"] = [];
    const tagFile: DataPackFile<FileType.Tag> = {
      type: FileType.Tag,
      filename,
      toString: (): string => {
        if (!queue.includes(tagFile)) {
          queue.push(tagFile);
        }
        return `#${namespace}:${name}`;
      },
      content(): string {
        if (values.length === 0) {
          return "";
        }

        const data = {
          values: values.map(String),
        };

        return JSON.stringify(data, null, 2);
      },
    };
    // @ts-ignore
    tagFile.id = Math.random();

    const tag: Tag<T> = Object.assign(
      (...newValues: typeof values): void => {
        values.push(...newValues);
      },
      tagFile,
      { values }
    );
    return tag;
  }

  public makeTag<T extends TagType>(type: T, name: string): Tag<T> {
    return this.namespacedTag(this.namespace, type, name);
  }
}

export function selector(
  name: string,
  args: SelectorArgs = {}
): SelectorFunction {
  const sel = (newArgs: SelectorArgs): Selector => {
    return selector(name, {
      ...args,
      ...newArgs,
    });
  };
  sel.toString = (): string => {
    const tmp = Object.keys(args).flatMap((arg) => {
      if (args[arg] != null) {
        return [`${arg}=${args[arg]}`];
      }
      return [];
    });
    if (tmp.length > 0) {
      return `${name}[${tmp.join(",")}]`;
    }
    return name;
  };
  sel.toJSON = sel.toString;

  return sel;
}
