/* eslint-disable @typescript-eslint/camelcase */
import * as path from "path";
import { queue, objectives } from "./queue";
import {
  ScoreboardInput,
  Scoreboard,
  CodeGenerator,
  McFunction,
  LootInput,
  DataPackFile,
  TagType,
  Tag,
  LootTable,
  FileType,
  Objective,
  Command,
} from "./types";
import { SelectorArgs, Selector, SelectorFunction } from "./game-types";
import { command, scoreboard } from "./commands";
import { mcLoad } from ".";

export default class DataPack {
  private initScoreboards: Command[];

  constructor(private namespace: string, private scoreboardNamespace: string) {
    const initScoreboards: Command[] = [];
    // TODO: use this to initialize scoreboards. I can't call mcLoad from
    // DataPack's constructor, because it's a function on DataPack.
    this.initScoreboards = initScoreboards;

    // const initialize_scoreboards = this.mcFunction(
    //   function* initialize_scoreboards() {
    //     for (let index = 0; index < initScoreboards.length; index++) {
    //       yield initScoreboards[index];
    //     }
    //   }
    // );
    // mcLoad(initialize_scoreboards);
  }

  public makeScoreboard<T extends ScoreboardInput>(
    namespace: string,
    variables: T
  ): Scoreboard<T> {
    const scoreboard = {} as Scoreboard<T>;
    for (const name in variables) {
      if (variables.hasOwnProperty(name)) {
        const criteria = variables[name];

        scoreboard[name] = this.objective(name, criteria);
      }
    }
    return scoreboard;
  }

  public objective(name: string, criteria: Objective["criteria"]): Objective {
    objectives.push(
      `scoreboard objectives add ${this.scoreboardNamespace}.${name} ${criteria}\n`
    );
    let fullName: string;
    const myObjective = {
      criteria,
      name,
      toString: (): string => {
        if (!fullName) {
          fullName = `${this.scoreboardNamespace}.${name}`;
          this.initScoreboards.push(
            scoreboard("objectives", "add", myObjective)
          );
        }
        return fullName;
      },
    };
    return myObjective;
  }

  public mcFunction(fn: CodeGenerator, name: string = fn.name): McFunction {
    if (!name) {
      throw new Error(
        "missing name. Either use a function declaration or pass a name"
      );
    }
    const filename = path.join(
      "data",
      this.namespace,
      "functions",
      `${name}.mcfunction`
    );

    const mcFn: McFunction = Object.assign(fn, {
      type: FileType.McFunction,
      filename,
      toString: (): string => {
        if (!queue.includes(mcFn)) {
          queue.push(mcFn);
        }
        return `${this.namespace}:${name}`;
      },
      content(): string {
        let content = "# Generated by ts-datapack\n\n";
        for (let cmd of fn()) {
          // If you just pass an McFunciton directly, this assumes you want to run it
          // with the `function` command. since funciton is a keyword in JS, I can't
          // make a function(fn: McFunction): string
          if (typeof cmd === "function") {
            cmd = command(`function ${cmd}`);
          }

          content += String(cmd).trim() + "\n\n";
        }
        return content
          .split(/\r?\n/)
          .map((s) => s.trim())
          .join("\n");
      },
    } as const);
    return mcFn;
  }

  public makeLootTable(name: string, table: LootInput): LootTable {
    const filename = path.join(
      "data",
      this.namespace,
      "loot_tables",
      `${name}.json`
    );

    const lootTable: LootTable = {
      type: FileType.LootTable,
      filename,
      toString: (): string => {
        const fullName = `${this.namespace}:${name}`;
        if (!queue.includes(lootTable)) {
          queue.push(lootTable);
        }
        return fullName;
      },
      content: (): string => JSON.stringify(table(), null, 2),
    };
    return lootTable;
  }

  public makeTag<T extends TagType>(type: T, name: string): Tag<T> {
    const filename = path.join(
      "data",
      this.namespace,
      "tags",
      type,
      name + ".json"
    );

    const values: Tag<T>["values"] = [];
    const tagFile: DataPackFile<FileType.Tag> = {
      type: FileType.Tag,
      filename,
      toString: (): string => {
        if (!queue.includes(tagFile)) {
          queue.push(tagFile);
        }
        return `#${this.namespace}:${name}`;
      },
      content(): string {
        if (values.length === 0) {
          return "";
        }

        const data = {
          values: values.map(String),
        };

        return JSON.stringify(data, null, 2);
      },
    };

    const tag: Tag<T> = Object.assign(
      (...newValues: typeof values): void => {
        values.push(...newValues);
      },
      tagFile,
      { values }
    );
    return tag;
  }
}

export function selector(
  name: string,
  args: SelectorArgs = {}
): SelectorFunction {
  const sel = (newArgs: SelectorArgs): Selector => {
    return selector(name, {
      ...args,
      ...newArgs,
    });
  };
  sel.toString = (): string => {
    const tmp = Object.keys(args).flatMap((arg) => {
      if (args[arg] != null) {
        return [`${arg}=${args[arg]}`];
      }
      return [];
    });
    if (tmp.length > 0) {
      return `${name}[${tmp.join(",")}]`;
    }
    return name;
  };
  sel.toJSON = sel.toString;

  return sel;
}
