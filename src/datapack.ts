import * as path from "path";
import { objectives, queue } from "./queue";
import {
  ScoreboardInput,
  Scoreboard,
  CodeGenerator,
  McFunction,
  LootInput,
  DataPackFile,
  TagType,
  Tag,
  LootTable,
  FileType,
} from "./types";
import { SelectorArgs, Selector, SelectorFunction } from "./game-types";
import { command } from "./commands";

export default class DataPack {
  constructor(private namespace: string) {}

  public makeScoreboard<T extends ScoreboardInput>(
    namespace: string,
    variables: T
  ): Scoreboard<T> {
    const scoreboard = {} as Scoreboard<T>;
    for (const name in variables) {
      if (variables.hasOwnProperty(name)) {
        const type = variables[name];

        scoreboard[name] = {
          toString: (): string => {
            return `${namespace}.${name}`;
          },
        };
        objectives.push(
          `scoreboard objectives add ${scoreboard[name]} ${type}\n`
        );
      }
    }
    return scoreboard;
  }

  public mcFunction(fn: CodeGenerator, name: string = fn.name): McFunction {
    if (!name) {
      throw new Error(
        "missing name. Either use a function declaration or pass a name"
      );
    }
    const filename = path.join(
      "data",
      this.namespace,
      "functions",
      `${name}.mcfunction`
    );

    const mcFn: McFunction = Object.assign(fn, {
      type: FileType.McFunction,
      filename,
      toString: (): string => {
        if (!queue.includes(mcFn)) {
          queue.push(mcFn);
        }
        return `${this.namespace}:${name}`;
      },
      content(): string {
        let content = "# Generated by ts-datapack\n\n";
        for (let cmd of fn()) {
          // If you just pass an McFunciton directly, this assumes you want to run it
          // with the `function` command. since funciton is a keyword in JS, I can't
          // make a function(fn: McFunction): string
          if (typeof cmd === "function") {
            cmd = command(`function ${cmd}`);
          }

          content += String(cmd).trim() + "\n\n";
        }
        return content
          .split(/\r?\n/)
          .map((s) => s.trim())
          .join("\n");
      },
    } as const);
    return mcFn;
  }

  public makeLootTable(name: string, table: LootInput): LootTable {
    const filename = path.join(
      "data",
      this.namespace,
      "loot_tables",
      `${name}.json`
    );

    const lootTable: LootTable = {
      type: FileType.LootTable,
      filename,
      toString: (): string => {
        const fullName = `${this.namespace}:${name}`;
        if (!queue.includes(lootTable)) {
          queue.push(lootTable);
        }
        return fullName;
      },
      content: (): string => JSON.stringify(table(), null, 2),
    };
    return lootTable;
  }

  public makeTag<T extends TagType>(type: T, name: string): Tag<T> {
    const filename = path.join(
      "data",
      this.namespace,
      "tags",
      type,
      name + ".json"
    );

    const values: Tag<T>["values"] = [];
    const tagFile: DataPackFile<FileType.Tag> = {
      type: FileType.Tag,
      filename,
      toString: (): string => {
        if (!queue.includes(tagFile)) {
          queue.push(tagFile);
        }
        return `#${this.namespace}:${name}`;
      },
      content(): string {
        if (values.length === 0) {
          return "";
        }

        const data = {
          values: values.map(String),
        };

        return JSON.stringify(data, null, 2);
      },
    };

    const tag: Tag<T> = Object.assign(
      (...newValues: typeof values): void => {
        values.push(...newValues);
      },
      tagFile,
      { values }
    );
    return tag;
  }

  public createSelector(
    name: string,
    args: SelectorArgs = {}
  ): SelectorFunction {
    const selector = (newArgs: SelectorArgs): Selector => {
      return this.createSelector(name, {
        ...args,
        ...newArgs,
      });
    };
    selector.toString = (): string => {
      const tmp = Object.keys(args).flatMap((arg) => {
        if (args[arg] != null) {
          return [`${arg}=${args[arg]}`];
        }
        return [];
      });
      if (tmp.length > 0) {
        return `${name}[${tmp.join(",")}]`;
      }
      return name;
    };
    selector.toJSON = selector.toString;

    return selector;
  }
}
